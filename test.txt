//单元测试:运算符、注释、分界符、空白跳过
[]().->,-;++;-- * & ! ~;/;%<<;>> >= > <= < == != && ^ || | |= &= ? : { }
/*单元测试:标识符和关键字*/
auto sizeof do while if else char case continue auto1 auto2 do232 _case class const default double extern float for int goto long return register static signed unsigned void volatile union typedef switchm switch short__16 short
//单元测试：常量
123 123E+3 123.34E-2 44.23
'\x64''\t''\144'
"asdfsdf\"sdfsadf\t\x64123\14423\\\'"
/*
*集成测试
*/
int main(int argc, char** argv)
{
	if (argc == 1) {
		buffer.fileName = argv[1];
		const char* temp = "test.txt";
		char ttemp[9];
		for (int i = 0; i < 8; i++)ttemp[i] = temp[i];
		ttemp[8] = 0;
		buffer.fileName = ttemp;
	}
	else if (argc == 2) {
		buffer.fileName = argv[1];
	}
	else if (argc == 3) {
		buffer.fileName = argv[1];
		buffer.outfileName = argv[2];
	}

	case 25:
			if (ch == '\\') {
				state = 26;
			}
			else if (ch == '\'') {
				token = new TOKEN(TAG_CH);
				token->num(charnum);
				return token;
			}
			else {
				charnum <<= 16;
				charnum += ch;
				state = 25;
			}
			break;
		case 26:
			if (ch == 'a' || ch == 'b' || ch == 'f' || ch == 'n' || ch == 'r' || ch == 't' || ch == 'v' || ch == '\\' || ch == '"' || ch == '\'') {
				char temp = ch;
				switch (ch)
				{
				case 'a':
					temp = '\a';
					break;
				case 'b':
					temp = '\b';
					break;
				case 'f':
					temp = '\f';


void printTOKEN(TOKEN* t) {
	if (buffer.outfileName == nullptr) {
		char temp[12] = "outcome.txt";
		buffer.outfileName = temp;
	}
	static ofstream outTest(buffer.outfileName, ios::out);
	switch (t->tag)
	{
	case TAG_POINTER:
		outTest << "< -> >" << endl;
		break;
	case TAG_SELFADD:
		outTest << "< ++ >" << endl;
		break;
	case TAG_SELFSUB:
		outTest << "< -- >" << endl;
		break;
	case TAG_SIZEOF:
		outTest << "< sizeof >" << endl;
		break;
	case TAG_LEFTSHIFT:
		outTest << "< << >" << endl;
		break;
	case TAG_RIGHTSHIFT:
		outTest << "< >> >" << endl;
		break;
	case TAG_GE:
		outTest << "< >= >" << endl;
		break;
	case TAG_LE:
		outTest << "< <= >" << endl;
		break;
	case TAG_EQ:
		outTest << "< == >" << endl;
		break;
	case TAG_NEQ:
		outTest << "< != >" << endl;
		break;
	case TAG_AND:
		outTest << "< && >" << endl;
		break;
	case TAG_OR:
		outTest << "< || >" << endl;
		break;
	case TAG_DIV_ASSIGN:
		outTest << "< /= >" << end;
		break;
	case TAG_BITAND_ASSIGN:
		outTest << "< &= >" << endl;
		break;
	case TAG_BITNOR_ASSIGN:
		outTest << "< ^= >" << endl;
		break;
	case TAG_BITOR_ASSIGN:
		outTest << "< |= >" << endl;
		break;
	case TAG_AUTO:
		outTest << "< auto >" << endl;
		break;
	case TAG_BREAK:
		outTest << "< break >" << endl;
		break;
	case TAG_CASE:
		outTest << "< case >" << endl;
		break;
	case TAG_CHAR:
		outTest << "< char >" << endl;
		break;
	case TAG_CONST:
		outTest << "< const >" << endl;
		break;
	case TAG_CONTINUE:
		outTest << "< continue >" << endl;
		break;
	case TAG_DEFAULT:
		outTest << "< default >" << endl;
		break;
	case TAG_DO:
		outTest << "< do >" << endl;
		break;
	case TAG_DOUBLE:
		outTest << "< double >" << endl;
		break;
	case TAG_ELSE:
		outTest << "< else >" << endl;
		break;
	case TAG_ENUM:
		outTest << "< enum >" << endl;
		break;
	case TAG_EXTERN:
		outTest << "< extern >" << endl;
		break;
	case TAG_FLOAT:
		outTest << "< float >" << endl;
		break;
	default:
		outTest << "< " << (char)t->tag << " >" << endl;
		break;
	}
}